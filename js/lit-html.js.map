{"version":3,"file":"lit-html.js","sourceRoot":"","sources":["src/lit-html.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\n\r\n/**\r\n * TypeScript has a problem with precompiling templates literals\r\n * https://github.com/Microsoft/TypeScript/issues/17956\r\n *\r\n * TODO(justinfagnani): Run tests compiled to ES5 with both Babel and\r\n * TypeScript to verify correctness.\r\n */\r\nconst envCachesTemplates =\r\n    ((t: any) => t() === t())(() => ((s: TemplateStringsArray) => s) ``);\r\n\r\n// The first argument to JS template tags retain identity across multiple\r\n// calls to a tag for the same literal, so we can cache work done per literal\r\n// in a Map.\r\nconst templates = new Map<TemplateStringsArray|string, Template>();\r\nconst svgTemplates = new Map<TemplateStringsArray|string, Template>();\r\n\r\n/**\r\n * Interprets a template literal as an HTML template that can efficiently\r\n * render to and update a container.\r\n */\r\nexport const html = (strings: TemplateStringsArray, ...values: any[]) =>\r\n    litTag(strings, values, templates, false);\r\n\r\n/**\r\n * Interprets a template literal as an SVG template that can efficiently\r\n * render to and update a container.\r\n */\r\nexport const svg = (strings: TemplateStringsArray, ...values: any[]) =>\r\n    litTag(strings, values, svgTemplates, true);\r\n\r\nfunction litTag(\r\n    strings: TemplateStringsArray,\r\n    values: any[],\r\n    templates: Map<TemplateStringsArray|string, Template>,\r\n    isSvg: boolean): TemplateResult {\r\n  const key = envCachesTemplates ?\r\n      strings :\r\n      strings.join('{{--uniqueness-workaround--}}');\r\n  let template = templates.get(key);\r\n  if (template === undefined) {\r\n    template = new Template(strings, isSvg);\r\n    templates.set(key, template);\r\n  }\r\n  return new TemplateResult(template, values);\r\n}\r\n\r\n/**\r\n * The return type of `html`, which holds a Template and the values from\r\n * interpolated expressions.\r\n */\r\nexport class TemplateResult {\r\n  template: Template;\r\n  values: any[];\r\n\r\n  constructor(template: Template, values: any[]) {\r\n    this.template = template;\r\n    this.values = values;\r\n  }\r\n}\r\n\r\n/**\r\n * Renders a template to a container.\r\n *\r\n * To update a container with new values, reevaluate the template literal and\r\n * call `render` with the new result.\r\n */\r\nexport function render(\r\n    result: TemplateResult,\r\n    container: Element|DocumentFragment,\r\n    partCallback: PartCallback = defaultPartCallback) {\r\n  let instance = (container as any).__templateInstance as any;\r\n\r\n  // Repeat render, just call update()\r\n  if (instance !== undefined && instance.template === result.template &&\r\n      instance._partCallback === partCallback) {\r\n    instance.update(result.values);\r\n    return;\r\n  }\r\n\r\n  // First render, create a new TemplateInstance and append it\r\n  instance = new TemplateInstance(result.template, partCallback);\r\n  (container as any).__templateInstance = instance;\r\n\r\n  const fragment = instance._clone();\r\n  instance.update(result.values);\r\n\r\n  let child;\r\n  while ((child = container.lastChild)) {\r\n    container.removeChild(child);\r\n  }\r\n  container.appendChild(fragment);\r\n}\r\n\r\n/**\r\n * An expression marker with embedded unique key to avoid\r\n * https://github.com/PolymerLabs/lit-html/issues/62\r\n */\r\nconst attributeMarker = `{{lit-${Math.random()}}}`;\r\n\r\n/**\r\n * Regex to scan the string preceding an expression to see if we're in a text\r\n * context, and not an attribute context.\r\n *\r\n * This works by seeing if we have a `>` not followed by a `<`. If there is a\r\n * `<` closer to the end of the strings, then we're inside a tag.\r\n */\r\nconst textRegex = />[^<]*$/;\r\nconst hasTagsRegex = /[^<]*/;\r\nconst textMarkerContent = '_-lit-html-_';\r\nconst textMarker = `<!--${textMarkerContent}-->`;\r\nconst attrOrTextRegex = new RegExp(`${attributeMarker}|${textMarker}`);\r\nconst lastAttributeNameRegex =\r\n    /((?:\\w|[.\\-_$])+)=(?:[^\"']*|(?:[\"][^\"]*)|(?:['][^']*))$/;\r\n\r\n/**\r\n * A placeholder for a dynamic expression in an HTML template.\r\n *\r\n * There are two built-in part types: AttributePart and NodePart. NodeParts\r\n * always represent a single dynamic expression, while AttributeParts may\r\n * represent as many expressions are contained in the attribute.\r\n *\r\n * A Template's parts are mutable, so parts can be replaced or modified\r\n * (possibly to implement different template semantics). The contract is that\r\n * parts can only be replaced, not removed, added or reordered, and parts must\r\n * always consume the correct number of values in their `update()` method.\r\n *\r\n * TODO(justinfagnani): That requirement is a little fragile. A\r\n * TemplateInstance could instead be more careful about which values it gives\r\n * to Part.update().\r\n */\r\nexport class TemplatePart {\r\n  constructor(\r\n      public type: string, public index: number, public name?: string,\r\n      public rawName?: string, public strings?: string[]) {\r\n  }\r\n}\r\n\r\n\r\nexport class Template {\r\n  parts: TemplatePart[] = [];\r\n  element: HTMLTemplateElement;\r\n  svg: boolean;\r\n\r\n  constructor(strings: TemplateStringsArray, svg: boolean = false) {\r\n    this.svg = svg;\r\n    this.element = document.createElement('template');\r\n    this.element.innerHTML = this._getHtml(strings, svg);\r\n    // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\r\n    const walker = document.createTreeWalker(\r\n        this.element.content,\r\n        133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\r\n               NodeFilter.SHOW_TEXT */\r\n        ,\r\n        null as any,\r\n        false);\r\n    let index = -1;\r\n    let partIndex = 0;\r\n    const nodesToRemove: Node[] = [];\r\n\r\n    // The actual previous node, accounting for removals: if a node is removed\r\n    // it will never be the previousNode.\r\n    let previousNode: Node|undefined;\r\n    // Used to set previousNode at the top of the loop.\r\n    let currentNode: Node|undefined;\r\n\r\n    while (walker.nextNode()) {\r\n      index++;\r\n      previousNode = currentNode;\r\n      const node = currentNode = walker.currentNode as Element;\r\n      if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\r\n        if (!node.hasAttributes()) {\r\n          continue;\r\n        }\r\n        const attributes = node.attributes;\r\n        // Per https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\r\n        // attributes are not guaranteed to be returned in document order. In\r\n        // particular, Edge/IE can return them out of order, so we cannot assume\r\n        // a correspondance between part index and attribute index.\r\n\r\n        // Do a first pass to count attributes that correspond to parts.\r\n        const attributesWithParts: string[][] = Array.prototype.filter.call(\r\n            attributes,\r\n            (attribute: Attr) =>\r\n                attribute.value.split(attrOrTextRegex).length > 1);\r\n        // Loop that many times, but don't use loop index for anything.\r\n        for (let i = 0; i < attributesWithParts.length; i++) {\r\n          // Get the template literal section leading up to the first\r\n          // expression in this attribute attribute\r\n          const stringForPart = strings[partIndex];\r\n          // Find the attribute name\r\n          const attributeNameInPart = stringForPart.match(lastAttributeNameRegex)![1];\r\n          // Find the corresponding attribute\r\n          const attribute = attributes.getNamedItem(attributeNameInPart);\r\n          const stringsForAttributeValue =\r\n              attribute.value.split(attrOrTextRegex);\r\n          this.parts.push(new TemplatePart(\r\n              'attribute',\r\n              index,\r\n              attribute.name,\r\n              attributeNameInPart,\r\n              stringsForAttributeValue));\r\n          node.removeAttribute(attribute.name);\r\n          partIndex += stringsForAttributeValue.length - 1;\r\n        }\r\n      } else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\r\n        const nodeValue = node.nodeValue!;\r\n        const strings = nodeValue.split(attrOrTextRegex);\r\n        if (strings.length > 1) {\r\n          const parent = node.parentNode!;\r\n          const lastIndex = strings.length - 1;\r\n\r\n          // We have a part for each match found\r\n          partIndex += lastIndex;\r\n\r\n          // We keep this current node, but reset its content to the last\r\n          // literal part. We insert new literal nodes before this so that the\r\n          // tree walker keeps its position correctly.\r\n          node.textContent = strings[lastIndex];\r\n\r\n          // Generate a new text node for each literal section\r\n          // These nodes are also used as the markers for node parts\r\n          for (let i = 0; i < lastIndex; i++) {\r\n            parent.insertBefore(document.createTextNode(strings[i]), node);\r\n            this.parts.push(new TemplatePart('node', index++));\r\n          }\r\n        } else {\r\n          // Strip whitespace-only nodes, only between elements, or at the\r\n          // beginning or end of elements.\r\n          const previousSibling = node.previousSibling;\r\n          const nextSibling = node.nextSibling;\r\n          if ((previousSibling === null ||\r\n               previousSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&\r\n              (nextSibling === null ||\r\n               nextSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&\r\n              nodeValue.trim() === '') {\r\n            nodesToRemove.push(node);\r\n            currentNode = previousNode;\r\n            index--;\r\n          }\r\n        }\r\n      } else if (\r\n          node.nodeType === 8 /* Node.COMMENT_NODE */ &&\r\n          node.nodeValue === textMarkerContent) {\r\n        const parent = node.parentNode!;\r\n        // If we don't have a previous node add a marker node.\r\n        // If the previousSibling is removed, because it's another part\r\n        // placholder, or empty text, add a marker node.\r\n        if (node.previousSibling === null ||\r\n            node.previousSibling !== previousNode) {\r\n          parent.insertBefore(document.createTextNode(''), node);\r\n        } else {\r\n          index--;\r\n        }\r\n        this.parts.push(new TemplatePart('node', index++));\r\n        nodesToRemove.push(node);\r\n        // If we don't have a next node add a marker node.\r\n        // We don't have to check if the next node is going to be removed,\r\n        // because that node will induce a marker if so.\r\n        if (node.nextSibling === null) {\r\n          parent.insertBefore(document.createTextNode(''), node);\r\n        } else {\r\n          index--;\r\n        }\r\n        currentNode = previousNode;\r\n        partIndex++;\r\n      }\r\n    }\r\n\r\n    // Remove text binding nodes after the walk to not disturb the TreeWalker\r\n    for (const n of nodesToRemove) {\r\n      n.parentNode!.removeChild(n);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a string of HTML used to create a <template> element.\r\n   */\r\n  private _getHtml(strings: TemplateStringsArray, svg?: boolean): string {\r\n    const l = strings.length;\r\n    const a = [];\r\n    let isTextBinding = false;\r\n    for (let i = 0; i < l - 1; i++) {\r\n      const s = strings[i];\r\n      a.push(s);\r\n      // We're in a text position if the previous string matches the\r\n      // textRegex. If it doesn't and the previous string has no tags, then\r\n      // we use the previous text position state.\r\n      isTextBinding = s.match(textRegex) !== null ||\r\n          (s.match(hasTagsRegex) !== null && isTextBinding);\r\n      a.push(isTextBinding ? textMarker : attributeMarker);\r\n    }\r\n    a.push(strings[l - 1]);\r\n    const html = a.join('');\r\n    return svg ? `<svg>${html}</svg>` : html;\r\n  }\r\n}\r\n\r\nexport const getValue = (part: Part, value: any) => {\r\n  // `null` as the value of a Text node will render the string 'null'\r\n  // so we convert it to undefined\r\n  if (value != null && value.__litDirective === true) {\r\n    value = value(part);\r\n  }\r\n  return value === null ? undefined : value;\r\n};\r\n\r\nexport type DirectiveFn = (part: Part) => any;\r\n\r\nexport const directive = <F extends DirectiveFn>(f: F): F => {\r\n  (f as any).__litDirective = true;\r\n  return f;\r\n};\r\n\r\nexport interface Part {\r\n  instance: TemplateInstance;\r\n  size?: number;\r\n\r\n  // constructor(instance: TemplateInstance) {\r\n  //   this.instance = instance;\r\n  // }\r\n}\r\n\r\nexport interface SinglePart extends Part { setValue(value: any): void; }\r\n\r\nexport interface MultiPart extends Part {\r\n  setValue(values: any[], startIndex: number): void;\r\n}\r\n\r\nexport class AttributePart implements MultiPart {\r\n  instance: TemplateInstance;\r\n  element: Element;\r\n  name: string;\r\n  strings: string[];\r\n  size: number;\r\n\r\n  constructor(\r\n      instance: TemplateInstance, element: Element, name: string,\r\n      strings: string[]) {\r\n    this.instance = instance;\r\n    this.element = element;\r\n    this.name = name;\r\n    this.strings = strings;\r\n    this.size = strings.length - 1;\r\n  }\r\n\r\n  setValue(values: any[], startIndex: number): void {\r\n    const strings = this.strings;\r\n    let text = '';\r\n\r\n    for (let i = 0; i < strings.length; i++) {\r\n      text += strings[i];\r\n      if (i < strings.length - 1) {\r\n        const v = getValue(this, values[startIndex + i]);\r\n        if (v &&\r\n            (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\r\n          for (const t of v) {\r\n            // TODO: we need to recursively call getValue into iterables...\r\n            text += t;\r\n          }\r\n        } else {\r\n          text += v;\r\n        }\r\n      }\r\n    }\r\n    this.element.setAttribute(this.name, text);\r\n  }\r\n}\r\n\r\nexport class NodePart implements SinglePart {\r\n  instance: TemplateInstance;\r\n  startNode: Node;\r\n  endNode: Node;\r\n  private _previousValue: any;\r\n\r\n  constructor(instance: TemplateInstance, startNode: Node, endNode: Node) {\r\n    this.instance = instance;\r\n    this.startNode = startNode;\r\n    this.endNode = endNode;\r\n    this._previousValue = undefined;\r\n  }\r\n\r\n  setValue(value: any): void {\r\n    value = getValue(this, value);\r\n\r\n    if (value === null ||\r\n        !(typeof value === 'object' || typeof value === 'function')) {\r\n      // Handle primitive values\r\n      // If the value didn't change, do nothing\r\n      if (value === this._previousValue) {\r\n        return;\r\n      }\r\n      this._setText(value);\r\n    } else if (value instanceof TemplateResult) {\r\n      this._setTemplateResult(value);\r\n    } else if (Array.isArray(value) || value[Symbol.iterator]) {\r\n      this._setIterable(value);\r\n    } else if (value instanceof Node) {\r\n      this._setNode(value);\r\n    } else if (value.then !== undefined) {\r\n      this._setPromise(value);\r\n    } else {\r\n      // Fallback, will render the string representation\r\n      this._setText(value);\r\n    }\r\n  }\r\n\r\n  private _insert(node: Node) {\r\n    this.endNode.parentNode!.insertBefore(node, this.endNode);\r\n  }\r\n\r\n  private _setNode(value: Node): void {\r\n    if (this._previousValue === value) {\r\n      return;\r\n    }\r\n    this.clear();\r\n    this._insert(value);\r\n    this._previousValue = value;\r\n  }\r\n\r\n  private _setText(value: string): void {\r\n    const node = this.startNode.nextSibling!;\r\n    if (node === this.endNode.previousSibling &&\r\n        node.nodeType === Node.TEXT_NODE) {\r\n      // If we only have a single text node between the markers, we can just\r\n      // set its value, rather than replacing it.\r\n      // TODO(justinfagnani): Can we just check if _previousValue is\r\n      // primitive?\r\n      node.textContent = value;\r\n    } else {\r\n      this._setNode(document.createTextNode(value === undefined ? '' : value));\r\n    }\r\n    this._previousValue = value;\r\n  }\r\n\r\n  private _setTemplateResult(value: TemplateResult): void {\r\n    let instance: TemplateInstance;\r\n    if (this._previousValue &&\r\n        this._previousValue.template === value.template) {\r\n      instance = this._previousValue;\r\n    } else {\r\n      instance =\r\n          new TemplateInstance(value.template, this.instance._partCallback);\r\n      this._setNode(instance._clone());\r\n      this._previousValue = instance;\r\n    }\r\n    instance.update(value.values);\r\n  }\r\n\r\n  private _setIterable(value: any): void {\r\n    // For an Iterable, we create a new InstancePart per item, then set its\r\n    // value to the item. This is a little bit of overhead for every item in\r\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\r\n    // of TemplateResults that will be commonly returned from expressions like:\r\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\r\n\r\n    // If _previousValue is an array, then the previous render was of an\r\n    // iterable and _previousValue will contain the NodeParts from the previous\r\n    // render. If _previousValue is not an array, clear this part and make a new\r\n    // array for NodeParts.\r\n    if (!Array.isArray(this._previousValue)) {\r\n      this.clear();\r\n      this._previousValue = [];\r\n    }\r\n\r\n    // Lets us keep track of how many items we stamped so we can clear leftover\r\n    // items from a previous render\r\n    const itemParts = this._previousValue as any[];\r\n    let partIndex = 0;\r\n\r\n    for (const item of value) {\r\n      // Try to reuse an existing part\r\n      let itemPart = itemParts[partIndex];\r\n\r\n      // If no existing part, create a new one\r\n      if (itemPart === undefined) {\r\n        // If we're creating the first item part, it's startNode should be the\r\n        // container's startNode\r\n        let itemStart = this.startNode;\r\n\r\n        // If we're not creating the first part, create a new separator marker\r\n        // node, and fix up the previous part's endNode to point to it\r\n        if (partIndex > 0) {\r\n          const previousPart = itemParts[partIndex - 1];\r\n          itemStart = previousPart.endNode = document.createTextNode('');\r\n          this._insert(itemStart);\r\n        }\r\n        itemPart = new NodePart(this.instance, itemStart, this.endNode);\r\n        itemParts.push(itemPart);\r\n      }\r\n      itemPart.setValue(item);\r\n      partIndex++;\r\n    }\r\n\r\n    if (partIndex === 0) {\r\n      this.clear();\r\n      this._previousValue = undefined;\r\n    } else if (partIndex < itemParts.length) {\r\n      const lastPart = itemParts[partIndex - 1];\r\n      // Truncate the parts array so _previousValue reflects the current state\r\n      itemParts.length = partIndex;\r\n      this.clear(lastPart.endNode.previousSibling!);\r\n      lastPart.endNode = this.endNode;\r\n    }\r\n  }\r\n\r\n  protected _setPromise(value: Promise<any>): void {\r\n    value.then((v: any) => {\r\n      if (this._previousValue === value) {\r\n        this.setValue(v);\r\n      }\r\n    });\r\n    this._previousValue = value;\r\n  }\r\n\r\n  clear(startNode: Node = this.startNode) {\r\n    let node;\r\n    while ((node = startNode.nextSibling!) !== this.endNode) {\r\n      node.parentNode!.removeChild(node);\r\n    }\r\n  }\r\n}\r\n\r\nexport type PartCallback =\r\n    (instance: TemplateInstance, templatePart: TemplatePart, node: Node) =>\r\n        Part;\r\n\r\nexport const defaultPartCallback =\r\n    (instance: TemplateInstance,\r\n     templatePart: TemplatePart,\r\n     node: Node): Part => {\r\n      if (templatePart.type === 'attribute') {\r\n        return new AttributePart(\r\n            instance, node as Element, templatePart.name!, templatePart.strings!\r\n        );\r\n      } else if (templatePart.type === 'node') {\r\n        return new NodePart(instance, node, node.nextSibling!);\r\n      }\r\n      throw new Error(`Unknown part type ${templatePart.type}`);\r\n    };\r\n\r\n/**\r\n * An instance of a `Template` that can be attached to the DOM and updated\r\n * with new values.\r\n */\r\nexport class TemplateInstance {\r\n  _parts: Part[] = [];\r\n  _partCallback: PartCallback;\r\n  template: Template;\r\n\r\n  constructor(\r\n      template: Template, partCallback: PartCallback = defaultPartCallback) {\r\n    this.template = template;\r\n    this._partCallback = partCallback;\r\n  }\r\n\r\n  update(values: any[]) {\r\n    let valueIndex = 0;\r\n    for (const part of this._parts) {\r\n      if (part.size === undefined) {\r\n        (part as SinglePart).setValue(values[valueIndex]);\r\n        valueIndex++;\r\n      } else {\r\n        (part as MultiPart).setValue(values, valueIndex);\r\n        valueIndex += part.size;\r\n      }\r\n    }\r\n  }\r\n\r\n  _clone(): DocumentFragment {\r\n    const fragment = document.importNode(this.template.element.content, true);\r\n\r\n    if (this.template.parts.length > 0) {\r\n      // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\r\n      // null\r\n      const walker = document.createTreeWalker(\r\n          fragment,\r\n          133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\r\n                 NodeFilter.SHOW_TEXT */\r\n          ,\r\n          null as any,\r\n          false);\r\n\r\n      const parts = this.template.parts;\r\n      let index = 0;\r\n      let partIndex = 0;\r\n      let templatePart = parts[0];\r\n      let node = walker.nextNode();\r\n      while (node != null && partIndex < parts.length) {\r\n        if (index === templatePart.index) {\r\n          this._parts.push(this._partCallback(this, templatePart, node));\r\n          templatePart = parts[++partIndex];\r\n        } else {\r\n          index++;\r\n          node = walker.nextNode();\r\n        }\r\n      }\r\n    }\r\n    if (this.template.svg) {\r\n      const svgElement = fragment.firstChild!;\r\n      fragment.removeChild(svgElement);\r\n      const nodes = svgElement.childNodes;\r\n      for (let i = 0; i < nodes.length; i++) {\r\n        fragment.appendChild(nodes.item(i));\r\n      }\r\n    }\r\n    return fragment;\r\n  }\r\n}\r\n"]}