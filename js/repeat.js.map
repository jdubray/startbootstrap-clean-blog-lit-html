{"version":3,"file":"repeat.js","sourceRoot":"","sources":["../src/lib/repeat.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\n\r\nimport {directive, DirectiveFn, NodePart} from '../lit-html.js';\r\n\r\nexport type KeyFn<T> = (item: T) => any;\r\nexport type ItemTemplate<T> = (item: T, index: number) => any;\r\n\r\ninterface State {\r\n  keyMap: Map<any, NodePart>;\r\n  parts: NodePart[];\r\n}\r\n\r\nconst stateCache = new WeakMap<NodePart, State>();\r\n\r\nexport function repeat<T>(\r\n    items: T[], keyFn: KeyFn<T>, template: ItemTemplate<T>): DirectiveFn;\r\nexport function repeat<T>(items: T[], template: ItemTemplate<T>): DirectiveFn;\r\nexport function repeat<T>(\r\n    items: Iterable<T>,\r\n    keyFnOrTemplate: KeyFn<T>| ItemTemplate<T>,\r\n    template?: ItemTemplate<T>): DirectiveFn {\r\n  let keyFn: KeyFn<T>;\r\n  if (arguments.length === 2) {\r\n    template = keyFnOrTemplate;\r\n  } else if (arguments.length === 3) {\r\n    keyFn = keyFnOrTemplate as KeyFn<T>;\r\n  }\r\n\r\n  return directive((part: NodePart): any => {\r\n\r\n    let state = stateCache.get(part);\r\n    if (state === undefined) {\r\n      state = {\r\n        keyMap: keyFn && new Map(),\r\n        parts: [],\r\n      };\r\n      stateCache.set(part, state);\r\n    }\r\n    const container = part.startNode.parentNode as HTMLElement | ShadowRoot |\r\n        DocumentFragment;\r\n    const oldParts = state.parts;\r\n    const endParts = new Map<Node, NodePart>(\r\n        oldParts.map((p) => [p.endNode, p] as [Node, NodePart]));\r\n    const keyMap = state.keyMap;\r\n\r\n    const itemParts = [];\r\n    let index = 0;\r\n    let currentMarker: Node|undefined;\r\n\r\n    for (const item of items) {\r\n      let result;\r\n      let key;\r\n      try {\r\n        result = template !(item, index++);\r\n        key = keyFn && keyFn(item);\r\n      } catch (e) {\r\n        console.error(e);\r\n        continue;\r\n      }\r\n\r\n      // Try to reuse a part, either keyed or from the list of previous parts\r\n      // if there's no keyMap\r\n      let itemPart = keyMap === undefined ? oldParts[0] : keyMap.get(key);\r\n\r\n      if (itemPart === undefined) {\r\n        // New part, attach it\r\n        if (currentMarker === undefined) {\r\n          currentMarker = document.createTextNode('');\r\n          container.insertBefore(currentMarker, part.startNode.nextSibling);\r\n        }\r\n        const endNode = document.createTextNode('');\r\n        container.insertBefore(endNode, currentMarker.nextSibling);\r\n        itemPart = new NodePart(part.instance, currentMarker, endNode);\r\n        if (key !== undefined && keyMap !== undefined) {\r\n          keyMap.set(key, itemPart!);\r\n        }\r\n      } else {\r\n        // Existing part, maybe move it\r\n        const range = document.createRange();\r\n        range.setStartBefore(itemPart.startNode);\r\n        range.setEndBefore(itemPart.endNode);\r\n\r\n        if (currentMarker === undefined) {\r\n          // this should be the first part, make sure it's first\r\n          if (part.startNode.nextSibling !== itemPart.startNode) {\r\n            // move the whole part\r\n            // get previous and next parts\r\n            const previousPart = endParts.get(itemPart.startNode);\r\n            if (previousPart) {\r\n              previousPart.endNode = itemPart.endNode;\r\n              endParts.set(previousPart.endNode, previousPart);\r\n            }\r\n            const contents = range.extractContents();\r\n            if (part.startNode.nextSibling === part.endNode) {\r\n              // The container part was empty, so we need a new endPart\r\n              itemPart.endNode = document.createTextNode('');\r\n              container.insertBefore(\r\n                  itemPart.endNode, part.startNode.nextSibling);\r\n            } else {\r\n              // endNode should equal the startNode of the currently first part\r\n              itemPart.endNode = part.startNode.nextSibling!;\r\n            }\r\n            container.insertBefore(contents, part.startNode.nextSibling);\r\n          }\r\n          // else part is in the correct position already\r\n        } else if (currentMarker !== itemPart.startNode) {\r\n          // move to correct position\r\n          const previousPart = endParts.get(itemPart.startNode);\r\n          if (previousPart) {\r\n            previousPart.endNode = itemPart.endNode;\r\n            endParts.set(previousPart.endNode, previousPart);\r\n          }\r\n          const contents = range.extractContents();\r\n          container.insertBefore(contents, currentMarker);\r\n        }\r\n\r\n        // remove part from oldParts list so it's not cleaned up\r\n        oldParts.splice(oldParts.indexOf(itemPart), 1);\r\n      }\r\n      // else part is in the correct position already\r\n\r\n      itemPart.setValue(result);\r\n      itemParts.push(itemPart);\r\n      currentMarker = itemPart.endNode;\r\n    }\r\n\r\n    // Cleanup\r\n    if (oldParts.length > 0) {\r\n      const clearStart = oldParts[0].startNode;\r\n      const clearEnd = oldParts[oldParts.length - 1].endNode;\r\n      const clearRange = document.createRange();\r\n      if (itemParts.length === 0) {\r\n        clearRange.setStartBefore(clearStart);\r\n      } else {\r\n        clearRange.setStartAfter(clearStart);\r\n      }\r\n      clearRange.setEndAfter(clearEnd);\r\n      clearRange.deleteContents();\r\n      clearRange.detach();  // is this neccessary?\r\n    }\r\n\r\n    state.parts = itemParts;\r\n  });\r\n}\r\n"]}